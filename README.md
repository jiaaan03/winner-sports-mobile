Tugas 7
1. Di Flutter itu semuanya adalah widget seperti text, tombol, dan juga layout.  hubungan parent-childnya itu singkatnya induk bertugas untuk mengatur layout, data, dan posisi. Sedangkan anak/child itu bertugas untuk menampilkan dirinya sendiri sesuai dengan perintah yang diberikan oleh induknya.

2. Ada MyApp yang membungkus MaterialApp sebagai pengatur tema aplikasi. MyHomePage menggunakan Scaffold sebagai kerangka dasar untuk menyediakan AppBar dan body. Di dalam body inilah kita memakai Column sebagai rak penyusun utama untuk menata widget secara vertikal. Rak ini berisi sebuah Row yang menjajarkan tiga InfoCard yaitu NPM, nama. Lalu, diikuti oleh GridView yang menampilkan tiga ItemCard berwarna (yang berfungsi sebagai tombol menu utama). 

3. MaterialApp berfungsi untuk menyediakan semua infrastruktur penting seperti menetapkan tema (theme) global yang jadi sama untuk semua widget di bawahnya, dan juga menyediakan navigator yang mengelola tumpukan halaman sehingga bisa berpindah antar layar. Alasan MaterialApp harus menjadi widget root adalah agar semua widget di bawahnya (seperti Scaffold atau Dialog) bisa melihat dan mengakses layanan ini. Tanpa MaterialApp, widget lain akan kebingungan mencari tema atau cara bernavigasi

4. Perbedaan utamanya terletak pada memori/state. StatelessWidget itu tidak punya memori internal, dan hanya menampilkan data statis yang dioper dari induknya, tidak bisa berubah dari dalam. Sebaliknya, StatefulWidget itu dinamis, memiliki State (memori internal) yang bisa berubah-ubah seiring waktu. Kapanpun data di dalam State-nya berubah (misalnya karena klik tombol), ia bisa memicu rebuild (gambar ulang) dirinya sendiri dengan memanggil setState(). Pilihan penggunaannya sederhana: pilih StatelessWidget saat UI-nya diam dan hanya bergantung pada data dari luar. Pilih StatefulWidget saat perlu mengelola data yang berubah secara internal, seperti melacak apa yang diketik pengguna di TextField, dan mengelola status Checkbox

5. BuildContext sebagai alamat dari sebuah widget di dalam widget tree yang sangat besar. BuildContext ini penting karena ia adalah satu-satunya koneksi bagi widget untuk berinteraksi dengan widget lain yang ada di atasnya. penggunaannya gini misal, ScaffoldMessenger.of(context) untuk mencari Scaffold terdekat. Tanpa context, widget akan terisolasi, buta arah, dan tidak tahu apa-apa soal tema, navigator, atau widget lain di luar dirinya sendiri.

6. Hot reload adalah fitur andalan Flutter, fungsinya bisa menyuntikkan kode baru  ke aplikasi yang sedang berjalan tanpa menghilangkan State. Sedangkan, Hot restart akan memulai ulang seluruh aplikasi dari awal. Semua State akan hancur dan kembali ke nilai default-nya. Ini jauh lebih lambat daripada hot reload (tapi masih lebih cepat dari full build).

Tugas 8
1. Navigator.push() itu menambahkan rute baru ke atas tumpukan navigasi.  Method ini menyebabkan route yang ditambahkan berada pada paling atas stack, sehingga route yang baru saja ditambahkan tersebut akan muncul dan ditampilkan kepada pengguna.

Navigator.pushReplacement() itu method pushReplacement() menghapus route yang sedang ditampilkan kepada pengguna dan menggantinya dengan suatu route. Method ini menyebabkan aplikasi untuk berpindah dari route yang sedang ditampilkan kepada pengguna ke suatu route yang diberikan. Pada stack route yang dikelola Navigator, route lama pada atas stack akan digantikan secara langsung oleh route baru yang diberikan tanpa mengubah kondisi elemen stack yang berada di bawahnya.

Perbedaannya push() akan menambahkan route baru diatas route yang sudah ada pada atas stack, sedangkan pushReplacement() menggantikan route yang sudah ada pada atas stack dengan route baru tersebut.

2. Scaffold bertindak sebagai kerangka dasar untuk setiap halaman, menyediakan slot standar untuk appBar, body, dan drawer. Dengan menggunakan Scaffold di MyHomePage dan ProductFormPage, semua halaman memiliki tata letak dasar yang sama. AppBar  ditempatkan di slot appBar untuk memberikan judul yang sama yg diatur warnanya menggunakan tema aplikasi. Konsistensi tertinggi dicapai dengan Drawer yaitu membuat satu widget kustom, LeftDrawer, yang berisi semua tautan navigasi, dan kemudian memasukkan widget yang sama persis ke dalam slot drawer di setiap Scaffold untuk memastikan menu samping selalu identik di seluruh aplikasi.

3. Padding digunakan untuk memberi ruang bernapas di sekitar setiap TextFormField, sehingga input tidak saling menempel atau menempel di tepi layar, dan membuatnya terlihat rapi. Untuk mengatasi masalah keyboard yang menutupi input, bisa diatasi dengan  SingleChildScrollView. Hal ini memungkinkan pengguna untuk mengscroll konten, memastikan semua input, dan tombol Save tetap dapat diakses meskipun tinggi layar terbatas. ListView memiliki fungsi serupa dalam menyediakan scrolling otomatis dan digunakan di dalam LeftDrawer untuk menampung daftar menu.

4. Langkah utamanya adalah mengidentifikasi warna primer (primary color) dan warna sekunder (secondary color) yang digunakan oleh aplikasi. Warna-warna ini kemudian didefinisikan secara eksplisit dalam objek ThemeData pada Flutter, khususnya pada properti primarySwatch atau colorScheme. Dengan menetapkan tema terpusat ini di widget utama (MaterialApp), semua komponen UI seperti AppBar, floating action button (FAB), dan warna aksen tombol akan secara otomatis mengadopsi palet warna yang konsisten tersebut, memastikan bahwa aplikasi memancarkan identitas visual "Football Shop" yang kuat dan seragam di seluruh elemennya.

Tugas 9:
1. Konsekuensi memetakan langsung Map<String, dynamic> adalah data JSON bersifat dinamis. Ketika mengakses nilai dari Map<String, dynamic>, maka harus secara eksplisit melakukan casting ke tipe data misalnya map['field'] sebagai int. Lalu, dengan Map<String, dynamic>, kita tidak tahu apakah kunci tertentu benar-benar ada dalam data JSON. Kita harus berasumsi atau melakukan pemeriksaan manual setiap saat. Dan yang terakhir, Kode yang memetakan Map<String, dynamic> menjadi sangat berulang dan tidak intuitif. Untuk mengakses suatu nilai, kita harus selalu mengingat nama string dari kunci JSON (data['user_name']).
Model Dart berfungsi sebagai kontrak atau skema data yang di harapkan, membawa keuntungan keamanan tipe dan null-safety di waktu kompilasi, serta membuat kode lebih mudah dibaca, dikelola, dan diuji.

2. Package http menyediakan fondasi untuk melakukan segala jenis permintaan jaringan (GET, POST, dll.) dari aplikasi Dart/Flutter. Fungsinya adalah mengirim dan menerima data dari server.

CookieRequest adalah lapisan tambahan yang dibangun di atas http. Peran utamanya adalah mengotomatisasi penanganan cookies. Secara otomatis menyimpan cookies dari respons server dan melampirkannya kembali ke setiap permintaan berikutnya.

Perbedaannya http adalah alat dasar untuk komunikasi jaringan, sedangkan CookieRequest adalah manajer sesi yang memastikan cookies disertakan dalam permintaan yang dibuat oleh http.

3. Alasannya yaitu untuk mempertahaknkan otentikasi, jadi setelah login berhasil nanti cookie sesi hanya tersimpan di dalam instance CookieRequest tersebut. Konsistensi sesi, jadi semua permintaan jaringan berikutnya, dari mana pun asalnya harus menggunakan instance yang sama untuk secara otomatis melampirkan kembali cookie yang tersimpan ke header permintaan. Menghindari unauthenticated, jajdi jika komponen membuat CookieRequest yang baru, instance baru tersebut kosong, sehingga server akan menolak permintaan tersebut karena dianggap tidak terotentikasi.

4. Agar aplikasi Flutter dapat berkomunikasi dengan backend Django, maka diperlukan konfigurasi konektivitas di kedua sisi. Di sisi Django, kita wajib menambahkan alamat 10.0.2.2 ke dalam ALLOWED_HOSTS karena alamat ini adalah cara Emulator Android merujuk ke mesin host tempat server berjalan. Jika tidak, Django akan menolak koneksi dengan status 400. Selain itu, CORS harus diaktifkan untuk mengizinkan permintaan yang berasal dari origin Flutter yang berbeda, jika tidak permintaan akan diblokir. Pengaturan SameSite pada cookie juga harus disesuaikan untuk memastikan cookie sesi otentikasi dapat dipertahankan dan dikirimkan dengan benar lintas origin. Sementara itu, di sisi Flutter/Android, izin android.permission.INTERNET harus ditambahkan ke manifest agar aplikasi diizinkan sistem operasi untuk melakukan permintaan jaringan. Tanpa izin ini, semua upaya koneksi akan gagal karena Permission denied, artinya konfigurasi ini sangat penting untuk mencegah kegagalan di level otorisasi host, manajemen sesi, dan izin dasar sistem operasi.

5. Proses dimulai ketika pengguna memasukkan data. UI kemudian memicu fungsi yang menggunakan package http yang dibungkus oleh CookieRequest untuk membuat permintaan, biasanya POST. Data input tersebut dikemas menjadi objek Dart Model, yang kemudian diubah menjadi format JSON melalui serialisasi (toJson()) sebelum dikirimkan. Permintaan HTTP ini melintasi jaringan dan diterima oleh server Django. Backend Django menerima, memproses data, dan melakukan validasi. Setelah pemrosesan selesai, server membuat respons HTTP yang sering kali berupa JSON yang berisi status keberhasilan dan data yang diminta. Respons ini dikirim kembali ke aplikasi Flutter. Flutter menerima respons tersebut, memparsing JSON-nya, dan mengembalikannya menjadi objek Dart Model melalui deserialisasi. Data yang kini terstruktur dalam state aplikasi ini kemudian digunakan oleh fungsi setState() atau mekanisme state management lainnya untuk memperbarui UI Flutter, sehingga data atau hasilnya (seperti pesan sukses atau navigasi ke halaman berikutnya) dapat langsung ditampilkan kepada pengguna.

6. Mekanisme dimulai dari registrasi, yaitu pengguna memasukkan data di Flutter. Data tersebut dienkapsulasi dalam Dart Model lalu diserialisasi menjadi JSON. Flutter mengirimkan permintaan POST ke endpoint registrasi Django. Django menerima, memvalidasi data, menyimpan akun baru, dan mengirimkan respons sukses.
Lalu masuk ke bagian login, yaitu pengguna memasukkan kredensial. Flutter mengirimkan permintaan POST ke endpoint login Django. Jika kredensial valid, Django akan membuat Sesi dan mengirimkan Cookie Sesi dalam respons. Instance CookieRequest pada Flutter secara otomatis menyimpan cookie ini. Lalu akses terotentikasi, yaitu setelah login, setiap permintaan berikutnya dari Flutter akan secara otomatis melampirkan cookie sesi yang tersimpan ke header permintaan. Django membaca cookie tersebut, memverifikasi sesi, dan mengizinkan akses ke data terproteksi. Lalu tampilan menu, yaitu saat Flutter menerima respons sukses yang menunjukkan pengguna sudah terotentikasi, state aplikasi diperbarui untuk menampilkan menu atau elemen UI yang hanya tersedia bagi pengguna yang login. Dan yang terakhir logout yaitu flutter mengirimkan permintaan POST ke endpoint logout Django. Django menghancurkan sesi di server dan memberikan instruksi kepada client untuk mengakhiri sesi. Flutter kemudian menghapus cookie sesi yang tersimpan dan kembali ke tampilan awal.

7. Dimulai dengan memastikan konektivitas yang tepat, yaitu menjalankan deployment Django dan mengkonfigurasi ALLOWED_HOSTS dengan 10.0.2.2 serta mengaktifkan CORS agar Flutter Emulator dapat berkomunikasi. Di sisi frontend, kita mendefinisikan Model Dart (ItemModel) dengan metode fromJson untuk memetakan data JSON. Sistem autentikasi diimplementasikan dengan menggunakan instance CookieRequest secara  tunggal memungkinkan Halaman Registrasi dan Login untuk mengirim data akun, di mana instance ini secara otomatis menyimpan Cookie Sesi yang dikirim Django setelah login berhasil. Untuk Halaman Daftar Item, Flutter melakukan permintaan GET menggunakan CookieRequest yang terotentikasi; data JSON yang diterima di-parse menjadi ItemModel dan ditampilkan dalam list. Setiap item dapat diklik untuk navigasi ke Halaman Detail, di mana objek ItemModel diteruskan untuk menampilkan seluruh atribut. Terakhir, filter item berdasarkan pengguna yang login dicapai dengan memodifikasi view Django agar memfilter queryset berdasarkan request.user yang diidentifikasi melalui cookie sesi yang secara konsisten dikirim oleh client Flutter.